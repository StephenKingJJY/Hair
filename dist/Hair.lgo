;Hair_v2.2.1.20221209_package
;build time: Mon Dec 26 14:58:34 2022
;target os: fmslogo
make "hair_fallback_os "fmslogo
;------- main.lgo ---------
to hair [:debug "true]
ct window
make "CASEIGNOREDP "TRUE
pr [hair is starting...]
pr [StephenKing v2.2.1 @MIT License]
windowcreate "main "test "testH 100 0 1 1 []
dllload "user32.dll
make "hair_hwnd dllcall [L FindWindowA S FMSLogo L 0]
make "hair_window_radio dllcall [L FindWindowA S testH L 0]
dllload "Hair.dll
make "hair_window_radio 100/first dllcall se [L getWindowX L] :hair_window_radio
windowdelete "test
dllfree
ifelse or :debug = 0 :debug = "false [make "hair_debug "false][make "hair_debug "true]
ifelse :hair_debug [pr [debug mode on] hair.debug.tool setfocus [FMSLogo]] [make "erract [ts ct pr [Oops! There is an error in the program, please send the following information to program publisher for help.]]]
if 7.2 > hair.base.getitem (count item 2 logoversion)-2 item 2 logoversion [hair.debug.error [hair2.0 must run on FMSLogo which version is above 7.2.] stop]
if not member? "FMSLogo.exe files [hair.debug.error [current dir is wrong.] stop]
hair.noconflict "$
make "hair_keepword [class hair new hook all $ destroy cancel listen inherit method before after attr tip objectname havedefine] ;设置框架保留字
make "hair_version "2.2.1 ;hair框架版本
make "hair_language "zh_cn ;hair语言版本
make "hair_detect "false ;开启检测缓存
make "hair_turtle [39] ;标记占用海龟
make "hair_res "hair_res ;设定资源目录
make "hair_timeauth 0 ;初始化时间戳
make "hair_timer_id [] ;标记计时器占用id
make "hair_background_async [] ;支持异步语句
make "hair_hook_array $array 200 ;钩子数组的默认最大存储值为200
make "hair_hook_index [] ;设置一个索引，用于快速定位钩子函数
make "hair_object_list [] ;存储所有的对象名称
make "hair_object_class [] ;存储所有的类名
make "hair_object_havedefine [] ;为了简化调用而已经定义过的过程名称
make "hair_object_current " ;当前操作的对象，帮助简化调用
make "hair_resource_piclimit 40 ;图片资源缓存变量
make "hair_resource_picidlist [] ;图片id与名称对应表
if member? [幼圆] fontfacenames [($setfont -16 0 [幼圆])] ;设置字体，幼圆字体字号使中英文宽度一致
if member? [微软雅黑] fontfacenames [($setfont -16 0 [微软雅黑])] ;设置字体，有微软雅黑时使用雅黑，解决winxp
new "Project "Class
	;startup属性用来标记启动时调用的主入口文件，默认为main。这个文件需要在被load后自执行，比如添加startup变量。
	;filelist包含所有需要打包的文件，这些文件必须存在于主目录下
	;可能不是所有项目文件都需要在执行的时候被引用。还有个问题是拷贝的时候会丢失路径关系
	.attr [title untitle width 1000 height 1000 mode ss startup main.lgo filelist [main.lgo] needGUI false needRes false icon main.ico]
	.before [if not empty? hair.object.select "project [hair.debug.error _e "不能重复创建project对象 cancel] if :hair_debug [hair.base.settitle "untitle\(Hair\ on\ FMSLogo\)]]
	.listen "mode [run this.mode if this.mode="fs [if not :hair_debug [windowset "Commander 0 setfocus [FMSLogo]] make "hair_gui_listenkey "true]]
	.listen "title [hair.base.settitle this.title]
	;保存方法做几个操作：在dist下面新增项目文件夹，保存可被load的项目信息文件，创建引用入口文件，生成打包配置文件，拷贝项目文件
	.method "save [
		' [新增项目文件夹]
		localmake "_dir_restore hair.base.whatdir
		chdir :hair_maindir
		ifelse not member? "dist DIRECTORIES [mkdir "dist][chdir "dist]
		ifelse not member? this.title DIRECTORIES [mkdir this.title][chdir this.title]
		' [保存项目信息文件]
		openwrite word this.title ".hproj
		setwrite word this.title ".hproj
		pr [make "_projectname first hair.object.select "project]
		pr se [run se word :_projectname ".title.val quoted] quoted this.title
		pr se [run se word :_projectname ".width.val quoted] quoted this.width
		pr se [run se word :_projectname ".height.val quoted] quoted this.height
		pr se [run se word :_projectname ".mode.val quoted] quoted this.mode
		pr se [run se word :_projectname ".startup.val quoted] quoted this.startup
		pr se [run se word :_projectname ".needGUI.val quoted] quoted this.needGUI
		pr se [run se word :_projectname ".needRes.val quoted] quoted this.needRes
		pr se [run se word :_projectname ".icon.val quoted] quoted this.icon
		pr se [run list word :_projectname ".filelist.val] (list this.filelist)
		setwrite []
		close word this.title ".hproj
		' [创建引用入口文件]
		openwrite "_entry.lgo
		setwrite "_entry.lgo
		pr [make "startup [_entry]]
		pr [to _entry]
		pr [(hair "false)]
		if this.needGUI [pr "hairgui]
		pr [new "_p "project]
		pr se [_p.load] quoted this.title 
		pr se [load] quoted this.startup
		pr [end]
		setwrite []
		close "_entry.lgo
		' [生成打包配置文件]
		openwrite word this.title ".txt
		setwrite word this.title ".txt
		pr [\;!@Install@!UTF-8!]
		pr [GUIMode="2"]
		pr [MiscFlags="4"]
		pr (se [RunProgram="fmslogo -w] this.width [-h] this.height [-f -l _entry.lgo"])
		pr [\;!@InstallEnd@!]
		pr se [7zSFXBuilder_SFXName=] (word :hair_maindir "\\dist\\ this.title "\\ this.title ".exe)
		if not empty? this.icon [pr se [7zSFXBuilder_SFXIcon=] (word :hair_maindir "\\dist\\ this.title "\\ this.icon)]
		pr [7zSFXBuilder_UseDefMod=7zsd_LZMA2]
		pr se [7zSFXBuilder_SFXFile_1=] (word :hair_maindir "\\fmslogo.exe)
		pr se [7zSFXBuilder_SFXFile_2=] (word :hair_maindir "\\Hair.dll)
		pr se [7zSFXBuilder_SFXFile_3=] (word :hair_maindir "\\Hair.lgo)
		pr se [7zSFXBuilder_SFXFile_4=] (word :hair_maindir "\\startup.logoscript)
		pr se [7zSFXBuilder_SFXFile_5=] (word :hair_maindir "\\logolib\\)
		localmake "_i 6
		if this.needGUI [pr se (word "7zSFXBuilder_SFXFile_ :_i "=) (word :hair_maindir "\\HairGui.lgo) make "_i :_i+1]
		if this.needRes [pr se (word "7zSFXBuilder_SFXFile_ :_i "=) (word :hair_maindir "\\hair_res\\) make "_i :_i+1]
		foreach se this.filelist se "_entry.lgo word this.title ".hproj [
			pr se (word "7zSFXBuilder_SFXFile_ :_i "=) (word :hair_maindir "\\dist\\ this.title "\\ ? )
			make "_i :_i+1
		]
		pr [7zSFXBuilder_7Zip_Level=Ultra]
		pr [7zSFXBuilder_7Zip_Method=LZMA2]
		pr [7zSFXBuilder_7Zip_Dictionary=64 MB]
		pr [7zSFXBuilder_7Zip_BlockSize=Solid]
		setwrite []
		close word this.title ".txt
		' [拷贝项目文件]
		chdir :hair_maindir
		foreach this.filelist [
			hair.base.copyfile ? (word "dist\\ this.title "\\ ?)
		]
		' [回到初始目录]
		chdir :_dir_restore
		pr "保存完成
	]
	.method "load [[_projectname][
		ifelse :hair_debug [
		localmake "_dir_restore hair.base.whatdir
		chdir :hair_maindir
		chdir "dist
		chdir :_projectname
		load word :_projectname ".hproj
		chdir :_dir_restore][
			load word :_projectname ".hproj
		]]]
	.method "test [
		chdir :hair_maindir
		this.save
		pr "复制入口文件到主目录
		hair.base.copyfile (word "dist\\ this.title "\\_entry.lgo ) "_entry.lgo
		hair.base.copyfile (word "dist\\ this.title "\\ this.title ".hproj ) word this.title ".hproj 
		pr "启动测试
		ignore (hair.base.shell (se [fmslogo -w] this.width [-h] this.height [-f -l _entry.lgo]) "nooutput "vbs)
		pr "等待删除入口文件...
		wait 500
		pr "删除入口文件
		erf "_entry.lgo
		erf word this.title ".hproj 
	]
if :hair_debug [new "yourproject "Project]
new "Timer "Class
	.attr [id 1 delay 100 command [] mode noyield]
	.before [make "hair_timer_temp 0 for [i 1 31][
		if and (not member? :i :hair_timer_id)(:hair_timer_temp=0) [make "hair_timer_temp :i]]
		ifelse :hair_timer_temp = 0 [hair.debug.error "计时器已被用完 cancel][this.id.value :hair_timer_temp
		queue "hair_timer_id :hair_timer_temp]]
	.method "start [settimer this.id this.delay this.command]
	.method "stop [cleartimer this.id]
	.method "restart [this.stop this.start]
	.after [make "hair_timer_id remove this.id :hair_timer_id this.stop]
	;此处再定义当计时器的模式变更后的操作
	.listen "mode [if this.mode.h = this.mode [cancel]
		make "hair_timer_temp 0 ifelse this.mode="noyield [
		for [i 1 16] [if and (not member? :i :hair_timer_id) (:hair_timer_temp=0)[make "hair_timer_temp :i]]
		ifelse :hair_timer_temp = 0 [hair.debug.error "noyield模式计时器已被占满 cancel] [this.id.value :hair_timer_temp]
	] [
		for [i 17 31] [if and (not member? :i :hair_timer_id) (:hair_timer_temp=0)[make "hair_timer_temp :i]]
		ifelse :hair_timer_temp = 0 [hair.debug.error "yield模式计时器已被占满 cancel] [make "hair_timer_id remove this.id :hair_timer_id this.id.value :hair_timer_temp]
	]]
	.listen "id [ifelse member? this.id :hair_timer_id [hair.debug.error "该id已被占用 cancel][queue "hair_timer_id this.id make "hair_timer_id remove this.id.h :hair_timer_id]]
if not name? "hair_maindir [make "hair_maindir $whatdir]
if :hair_debug [pr se [Current main dir is] :hair_maindir]
new "hair_timer_data "Timer
	.mode.value "noyield
	.delay.value 1
	.command.value [hair.background.async.repeat hair.hook.create "hair_timer_data]
	.start
pr [hair is started.]
end
to hair.background.async :co
make "hair_background_async lput :co :hair_background_async
end
to hair.background.async.repeat
if empty? :hair_background_async [stop]
localmake "_co first :hair_background_async
make "hair_background_async bf :hair_background_async
run :_co
end
;------- base.lgo ---------
make "_allfiles_list []
to hair.base.allfiles
if or :hair_fallback_os = "lhogho :hair_fallback_os = "ucblogo [(throw "error [hair.base.allfiles do not supported on your platform.])]
make "_allfiles_list []
hair.base.allfiles.repeat
op :_allfiles_list
end
to hair.base.allfiles.repeat
make "_allfiles_list se files :_allfiles_list
if 2=count directories [stop]
repeat (count directories)-2 [chdir item repcount+2 directories hair.base.allfiles.repeat popdir]
end
to hair.base.timemilli.repeat 
end
if :hair_fallback_os = "lhogho [make "hair_fallback_handle libload "Kernel32.dll]
if :hair_fallback_os = "lhogho [external "hair.base.timemilli.repeat  [u4 GetTickCount] :hair_fallback_handle]
if :hair_fallback_os = "lhogho [libfree :hair_fallback_handle]
to hair.base.timemilli 
if :hair_fallback_os = "fmslogo [op timemilli]
if :hair_fallback_os = "ucblogo [(throw "error [hair.base.timemilli do not supported on your platform.])]
if :hair_fallback_os = "lhogho [ifelse :logoplatform = "Windows [
	op hair.base.timemilli.repeat
] [openfile "time_temp.htxt "w op last filetimes "time_temp.htxt erasefile "time_temp.htxt]]
end
to hair.base.copyfile.repeat :1 :2
end
if :hair_fallback_os = "lhogho [make "hair_fallback_handle libload "Kernel32.dll]
if :hair_fallback_os = "lhogho [external "hair.base.copyfile.repeat [v0 CopyFileA s1 s1] :hair_fallback_handle]
if :hair_fallback_os = "lhogho [libfree :hair_fallback_handle]
to hair.base.copyfile :n1 :n2
if :hair_fallback_os = "ucblogo [(throw "error [hair.base.copyfile do not supported on your platform.])]
if :hair_fallback_os = "lhogho [ifelse :logoplatform = "Windows [hair.base.copyfile.repeat :n1 :n2 stop][
	(throw "error [hair.base.copyfile do not supported on your platform.])
]]
dllload "Kernel32.dll
ignore dllcall (list "L "CopyFileA "S :n2 "S :n1)
dllfree
end
to hair.base.rename :n1 :n2
if :hair_fallback_os = "ucblogo [(throw "error [hair.base.rename do not supported on your platform.])]
if :hair_fallback_os = "lhogho [renamefile :n1 :n2 stop]
dllload "Kernel32.dll
ignore dllcall (list "L "MoveFileA "S :n2 "S :n1)
dllfree
end
to hair.base.whatdir
if :hair_fallback_os = "ucblogo [(throw "error [hair.base.whatdir do not supported on your platform.])]
if :hair_fallback_os = "lhogho [op currentfolder]
    local [workingDirectorySize lastError workingDirectory]
    dllload "kernel32.dll
    ; Call it with a NULL buffer to determine the required buffer size
    make "workingDirectorySize item 1 dllcall [L GetCurrentDirectoryA L 0 L 0]
    ifelse :workingDirectorySize = 0 [
        make "lastError dllcall [L GetLastError]
    ][
        make "workingDirectory item 2 dllcall (list "L "GetCurrentDirectoryA "B :workingDirectorySize "L :workingDirectorySize)
    ]
    dllfree
    if name? "lastError [ 
       (throw "Error (word "|Could get the working directory (error=| item 1 :lastError "|)|))
    ]
    ; Remove the NUL characters from the buffer
    output filter [NotEqual? char 0 ? ] :workingDirectory
end
to hair.base.arraysize :a
if not array? :a [hair.debug.error [param is not an array.] stop]
local "nothing
localmake "a_s 0
localmake "a2 :a
localmake "wakaka 0
while [:wakaka=0] [hair.base.makep "a_s catch "error [hair.old.aset :a2 hair.base.arraysize.repeat :a_s [] make "wakaka 1] ifelse :wakaka = 0 [make "wakaka 1] [make "wakaka 0]]
hair.base.makem "a_s
local "i
localmake "a_s2 hair.base.arraysize.repeat :a_s
for [i 1 :a_s][
  catch "error [forever [make "nothing hair.old.aget :a :a_s2 make "a_s2 (se hair.base.getitem :i-1 :a_s2 (item :i :a_s2)+1 hair.base.delitem :i :a_s2)]]
  make "a_s2 (se hair.base.getitem :i-1 :a_s2 (item :i :a_s2)-1 hair.base.delitem :i :a_s2)
]
op map [? + 1] :a_s2
end
to hair.base.arraysize.repeat :x
localmake "list0 []
repeat :x [queue "list0 0]
op :list0
end
to hair.base.asc :list
if :hair_fallback_os = "ucblogo [(throw "error [hair.base.asc do not supported on your platform.])]
if :hair_fallback_os = "lhogho [(throw "error [hair.base.asc do not supported on your platform.])]
op sort :list
end
to hair.base.desc :list
if :hair_fallback_os = "ucblogo [(throw "error [hair.base.desc do not supported on your platform.])]
if :hair_fallback_os = "lhogho [(throw "error [hair.base.desc do not supported on your platform.])]
op reverse sort :list
end
to hair.base.merge :v1 :v2
if and word? :v1 word? :v2 [op word :v1 :v2]
if and list? :v1 list? :v2 [op se :v1 :v2]
op list :v1 :v2
end
to hair.base.bmitem :n :v
if (count :v) < :n [hair.debug.error [over the length.] stop]
if (count :v) = :n [op bl :v]
if :n=1 [op bf :v]
local "temp1 
make "temp1 hair.base.getitem :n-1 :v
local "temp2 
make "temp2 hair.base.delitem :n :v
op hair.base.merge :temp1 :temp2
end
to hair.base.delitem :n :v
if :n<0 [hair.debug.error [param wrong] stop]
if :n > count :v [ifelse list? :v [op []] [op "]]
if :n=0 [op :v]
op hair.base.delitem :n-1 bf :v
end
to hair.base.getitem :n :v
if :n > (count :v) [op :v]
op hair.base.getitem.repeat (count :v) - :n :v
end
to hair.base.getitem.repeat :n :v
if :n<0 [hair.debug.error [param wrong] stop]
if :n=0 [op :v]
op hair.base.getitem.repeat :n-1 bl :v
end
to hair.base.hex2rgb :hex
if "# = first :hex [make "hex bf :hex]
local "myrgb
make "myrgb []
repeat 3 [make "myrgb se :myrgb hair.base.hex2rgb.repeat hair.base.getitem 2 :hex make "hex bf bf :hex]
op :myrgb
end
to hair.base.hex2rgb.repeat :hex
local "hexfirst
make "hexfirst first :hex
local "hexlast
make "hexlast last :hex
ifelse and (ascii :hexfirst)<103 (ascii :hexfirst)>96 [make "hexfirst (ascii :hexfirst)-87][
if and (ascii :hexfirst)<71 (ascii :hexfirst)>64 [make "hexfirst (ascii :hexfirst)-55]]
ifelse and (ascii :hexlast)<103 (ascii :hexlast)>96 [make "hexlast (ascii :hexlast)-87][
if and (ascii :hexlast)<71 (ascii :hexlast)>64 [make "hexlast (ascii :hexlast)-55]]
op :hexfirst*16+:hexlast
end
to hair.base.index :v :list
repeat count :list [
    if :v = item repcount :list [op repcount]
]
op 0
end
to hair.base.logoxy :xy
localmake "logoxy hair.object.select "Project
if empty? :logoxy [hair.debug.error [Project has not been defined.] stop]
op se (first :xy)-(run word first :logoxy ".width)/2 (run word first :logoxy ".height)/2-last :xy
end
to hair.base.screenxy :xy
localmake "logoxy hair.object.select "Project
if empty? :logoxy [hair.debug.error [Project has not been defined.] stop]
op se (run word first :logoxy ".width)/2+first :xy (run word first :logoxy ".height)/2-last :xy
end
.macro hair.base.makem :v
op (se "make quoted :v [-1+] "thing quoted :v)
end
.macro hair.base.makep :v
op (se "make quoted :v [1+] "thing quoted :v)
end
to hair.base.max :list
if :hair_fallback_os = "ucblogo [
    output reduce [ifelse ?1 > ?2 [?1] [?2]] :list
]
if :hair_fallback_os = "lhogho [(throw "error [hair.base.max do not supported on your platform.])]
op last sort :list
end
to hair.base.min :list
if :hair_fallback_os = "ucblogo [
    output reduce [ifelse ?1 < ?2 [?1] [?2]] :list
]
if :hair_fallback_os = "lhogho [(throw "error [hair.base.min do not supported on your platform.])]
op first sort :list
end
to hair.base.random :s :e
if not :hair_fallback_os = "ucblogo [(rerandom hair.base.timemilli)]
local "sew
ifelse (hair.base.random.repeat :s) > hair.base.random.repeat :e [make "sew hair.base.random.repeat :s] [make "sew hair.base.random.repeat :e]
if :sew = 0 [op :s + random (:e - :s)]
op :s + (random round :e*:sew-:s*:sew)/:sew
end
to hair.base.random.repeat :n
if empty? :n [op 0]
if ". = first :n [op power 10 count bf :n]
op hair.base.random.repeat bf :n
end
to hair.base.token :l
if not :hair_fallback_os = "ucblogo [(rerandom hair.base.timemilli)]
local "tokenlist
make "tokenlist []
local "tokenlist2 
make "tokenlist2 "
repeat :l [make "tokenlist se :tokenlist random 36]
repeat count :tokenlist [
  ifelse (item repcount :tokenlist) > 9 [make "tokenlist2 word :tokenlist2 char 97+(item repcount :tokenlist)-10][make "tokenlist2 word :tokenlist2 (item repcount :tokenlist)]
]
op :tokenlist2
end
to hair.base.safefirst :x
if empty? :x [
  ifelse word? :x [op "] [op []]
]
op first :x
end
to hair.base.safelast :x
if empty? :x [
  ifelse word? :x [op "] [op []]
]
op last :x
end
to hair.base.settitle :title
if :hair_fallback_os = "ucblogo [(throw "error [hair.base.settitle do not supported on your platform.])]
if :hair_fallback_os = "lhogho [(throw "error [hair.base.settitle do not supported on your platform.])]
dllload "user32.dll
local "result
make "result dllcall (list "L "SetWindowTextA "S :title "L :hair_hwnd)
dllfree 
end
to hair.base.shell :l [:callback "nooutput] [:mode "cmd] [:waitfile "nooutput]
ifelse word? :l [
  localmake "_output shell :l
][
if :mode = "cmd [localmake "_output shell se [cmd /c] :l]
if :mode = "bat [
  (openwrite "shell_temp.bat "true)
  setwrite "shell_temp.bat
  pr :l
  setwrite []
  close "shell_temp.bat
  localmake "_output shell [shell_temp.bat]
]
if :mode = "vbs [
  (openwrite "shell_temp.vbs "true)
  setwrite "shell_temp.vbs
  pr (se [createobject("wscript.shell").run "cmd /c] :l [",0])
  setwrite []
  close "shell_temp.vbs
  localmake "_output shell [wscript shell_temp.vbs]
]
if :mode = "batvbs [
  (openwrite "shell_temp.bat "true)
  setwrite "shell_temp.bat
  pr :l
  close "shell_temp.bat
  (openwrite "shell_temp.vbs "true)
  setwrite "shell_temp.vbs
  pr [createobject("wscript.shell").run "shell_temp.bat",0]
  setwrite []
  close "shell_temp.vbs
  localmake "_output shell [wscript shell_temp.vbs]
]]
if :callback = "nooutput [op :_output]
ifelse :waitfile = "nooutput [
  do.until [wait 1] [member? :callback files]][
  do.until [wait 1] [member? :waitfile files]
]
openread :callback
setread :callback
make "_output readrawline
setread []
close :callback
erf :callback erf "shell_temp.vbs erf "shell_temp.bat
if not :waitfile = "nooutput [erf :waitfile]
op :_output
end
to hair.base.turtlefree
local "i
for [i 41 1000] [if not member? :i :hair_turtle [make "hair_turtle se :hair_turtle :i op :i]]
hair.debug.error [turtles over limit.]
end
to hair.old.aget :a :v
if and (not word? :a) (not array? :a) [hair.debug.error "获取数组语法错误 stop]
if and list? :v 1=count :v [make "v first :v]
if word? :a [make "a thing :a]
ifelse list? :v [op mditem map [? + 1] :v :a][op item :v+1 :a]
end
to hair.old.array :v
if number? :v [op array :v stop]
if and list? :v 1<count :v [op mdarray :v stop]
hair.debug.error "数组定义语法不正确
end
to hair.old.aset :a :v :c
if and (not word? :a) (not array? :a) [hair.debug.error "设置数组语法错误 stop]
if and list? :v 1=count :v [make "v first :v]
if word? :a [make "a thing :a]
ifelse list? :v [mdsetitem map [? + 1] :v :a :c][setitem :v+1 :a :c]
end
to hair.old.tt :text
rt 90 label :text lt 90
end
to hair.old.setfont :height :width [:font []] [:colour []] [:effects []]
  if emptyp :font [ make "font [Courier] ]
	if not emptyp :colour [setpencolor :colour]
	ifelse memberp "B :effects [ localmake "bold 900 ] [ localmake "bold 0 ]
	ifelse memberp "I :effects [ localmake "italic 1 ] [ localmake "italic 0 ]
	ifelse memberp "U :effects [ localmake "underline 1 ] [ localmake "underline 0 ]
	setlabelfont (list :font :height :width 0 :bold :italic :underline)
end
to hair.file.extension :e
if :hair_fallback_os = "ucblogo [(throw "error [hair.file.extension do not supported on your platform.])]
if :hair_fallback_os = "lhogho [op hair.file.extension.repeat files ". [] :e]
op hair.file.extension.repeat files [] :e 1
end
to hair.file.extension.repeat :curfile :curfile2 :e
if empty? :curfile [op :curfile2]
local "exfile
make "exfile first :curfile
if (count :exfile)>(count :e)+1 [
  if :e = hair.base.delitem (count :exfile)-(count :e) :exfile [
    make "curfile2 se :curfile2 :exfile
  ]
]
op hair.file.extension.repeat bf :curfile :curfile2 :e
end
to hair.base.movewindow
dllload "User32.dll
dllcall (list "L "MoveWindow "W "1 "L (item 13 machine) "L (item 12 machine) "L ((item 9 machine)-(item 13 machine))/2 "L ((item 8 machine)-(item 12 machine))/2 "L :hair_hwnd)
(dllfree "User32.dll)
end
to hair.base.mousexy
op $screenxy mousepos
end
;------- debug.lgo ---------
to hair.debug.tool
dllload "Hair.dll
localmake "_xy se dllcall se [L getWindowX L] :hair_hwnd dllcall se [L getWindowY L] :hair_hwnd
make "hair_debug_winxy se int (first :_xy)*:hair_window_radio int (last :_xy)*:hair_window_radio
(dllfree "Hair.dll)
windowcreate "main "debugger "Hair开发者工具 (first :hair_debug_winxy)-120 last :hair_debug_winxy 120 int (item 13 machine)*:hair_window_radio []
staticcreate "debugger "objmessage [hair_obj_list] 25 10 70 10
listboxcreate "debugger "objlist 25 25 70 30
buttoncreate "debugger "tip "显示对象tip 40 55 40 10 [hair.debug.tool.repeat2 first :hair_debug_winxy last :hair_debug_winxy]
staticcreate "debugger "classmessage [hair_obj_class] 25 75 70 10
listboxcreate "debugger "classlist 25 90 70 30
staticcreate "debugger "curobjmessage [hair_object_current:] 25 125 70 20
make "hair_debug_dribble 0
buttoncreate "debugger "dri "开启日志 25 200 70 20 [ifelse :hair_debug_dribble=0 [make "hair_debug_dribble 1 dribble "hair_dirbble.txt
  buttonupdate "dri "停止日志][make "hair_debug_dribble 0 nodribble buttonupdate "dri "开启日志 WINDOWFILEEDIT "hair_dirbble.txt []]]
buttoncreate "debugger "refresh "刷新 35 250 20 10 [hair.debug.tool.repeat]
buttoncreate "debugger "end "关闭 65 250 20 10 [windowdelete "debugger]
end
to hair.debug.tool.repeat
listboxdelete "objlist listboxdelete "classlist
listboxcreate "debugger "objlist 25 25 70 30 listboxcreate "debugger "classlist 25 90 70 30
staticupdate "curobjmessage se [hair_object_current:] :hair_object_current
foreach :hair_object_list [listboxaddstring "objlist (list ?)]
repeat count :hair_object_class [listboxaddstring "classlist (list item repcount :hair_object_class)]
end
to hair.debug.tool.repeat2 :x :y
localmake "_objtip hair.debug.tool.repeat3 thing (word "hair_object_ first listboxgetselect "objlist "_tip)
ifelse 4=count :_objtip [
  windowcreate "debugger "wintip "对象tip :x :y 120 100+(10+10*int (count apply "word first last :_objtip)/20)+10+10*int (count apply "word first first bf :_objtip)/20 []
  buttoncreate "wintip "end2 "关闭 50 70+(10+10*int (count apply "word first last :_objtip)/20)+10+10*int (count apply "word first first bf :_objtip)/20 20 10 [windowdelete "wintip]
][
  windowcreate "debugger "wintip "对象tip :x :y 120 100+10+10*int (count apply "word first first bf :_objtip)/20 []
  buttoncreate "wintip "end2 "关闭 50 70+10+10*int (count apply "word first first bf :_objtip)/20 20 10 [windowdelete "wintip]
]
staticcreate "wintip "tipmessage1 first :_objtip 10 10 110 10
staticcreate "wintip "tipmessage2 first first bf :_objtip 10 20 110 10+10*int (count apply "word first first bf :_objtip)/20
if 4=count :_objtip [
  staticcreate "wintip "tipmessage3 first bf bf :_objtip 10 20+10+10*int (count apply "word first first bf :_objtip)/20 110 10
  staticcreate "wintip "tipmessage4 first last :_objtip 10 30+10+10*int (count apply "word first first bf :_objtip)/20 110 10+10*int (count apply "word first last :_objtip)/20 
]
end
to hair.debug.tool.repeat3 :l
localmake "_output [[您可以使用对象属性：]]
localmake "_m hair.debug.tool.repeat4 bf bf :l 1 1
make "_output se :_output (list (list hair.debug.tool.repeat5 hair.base.getitem :_m+2 :l []))
if (count :l)>:_m+2 [make "_output se :_output (list [您可以使用对象方法：] (list hair.base.delitem :_m+2 :l))]
op :_output
end
to hair.debug.tool.repeat4 :l :n :m
if empty? :l [op :m]
if (count first :l)>6 [
  if ".value =hair.base.delitem (count first :l)-6 first :l [op hair.debug.tool.repeat4 bf :l :n+1 :n]
]
op hair.debug.tool.repeat4 bf :l :n+1 :m
end
to hair.debug.tool.repeat5 :l :l2
if empty? :l [op :l2]
op hair.debug.tool.repeat5 bf remove word first :l ".val remove word first :l ".value :l lput first :l :l2
end
to hair.debug.error :msg
(throw "error :msg)
end
to hair.debug.' :a
end
to listbenchmark :limit
make "start hair.base.timemilli
make "a []
repeat :limit [	
  make "a fput 1000 :a
]
pr hair.base.timemilli-:start 
end
to hair.debug.restart 
ignore hair.base.shell [fmslogo]
bye
end
;------- hook.lgo ---------
to hair.hook.bind :action_name :command
if :action_name = "all [hair.debug.error word :action_name [action_name is illegal.] stop]
localmake "action_id 1 + count :hair_hook_index
ifelse not member? :action_name :hair_hook_index [make "hair_hook_index se :hair_hook_index :action_name][make "action_id hair.base.index :action_name :hair_hook_index] ;如果该过程被优先执行（即create过程尚未调用），则直接注册该钩子
hair.old.aset :hair_hook_array :action_id-1 se (hair.old.aget :hair_hook_array :action_id-1) :command
end
to hair.hook.clear :action_name
if :action_name = "all [make "hair_hook_array hair.old.array 200 make "hair_hook_index [] stop]
if not member? :action_name :hair_hook_index [hair.debug.error word :action_name [action_name do not exist.] stop]
hair.old.aset :hair_hook_array (hair.base.index :action_name :hair_hook_index)-1 []
end
to hair.hook.create :action_name
if :action_name = "all [hair.debug.error word :action_name [action_name is illegal.] stop]
if not member? :action_name :hair_hook_index [make "hair_hook_index se :hair_hook_index :action_name stop]
localmake "command hair.old.aget :hair_hook_array (hair.base.index :action_name :hair_hook_index)-1
ifelse not list? :command [run (se :command)][run :command]
end
;------- i18n.lgo ---------
to hair.i18n.text :text
$switch :text
$case [cannot create the object of Project more than once] [op "不能重复创建project对象]
op :text
end
to _e :text
op hair.i18n.text :text
end
;------- module.lgo ---------

make "hair_module_handshake []

make "hair_module_store []
make "hair_module_store_what_type []
make "hair_module_switch "
make "hair_module_id 1
make "hair_module_node "true

to hair.module.idgen
if :hair_module_id = 5000 [make "hair_module_id 1]
make "hair_module_id :hair_module_id+1
op word timemilli hair.base.token 3 :hair_module_id 
end

to hair.module.switch :test
make "hair_module_switch :test
end 
to hair.module.case :case :list
if :hair_module_switch = :case [run :list]
end

to hair.module.in :what :path
localmake "_id hair.module.idgen
queue "hair_module_handshake :_id 

localmake "exist 1
ifelse not member? :path :hair_module_store [make "exist 0 catch "error [load word :path ".lgo make "exist 1] catch "error [load :path make "exist 1] if :exist = 1 [queue "hair_module_store :path queue "hair_module_store_what_type thing word "hair_module_handshake_ :_id]] [
    make word "hair_module_handshake_ :_id item hair.base.index :path :hair_module_store :hair_module_store_what_type
]

ifelse and :hair_module_node :exist = 0 [
    queue "hair_module_store :path queue "hair_module_store_what_type "node
    make word "hair_module_handshake_ :_id [node]
    localmake "_path (word "\(\" :path "\"\) )
    define :what list [dot param] `[
        openwrite "module_temp.js
        setwrite "module_temp.js
        pr [var hair_fs = require (\"fs\")]
        pr [var ,:what = require ,:_path]
        ifelse empty? :dot [
            ifelse empty? :param [pr [var hair_var = ,@[word :what "\(\)]]][
                pr se [var hair_var =] (word ",:what "\( hair.module.node.param :param "\) )
            ]
        ][
            ifelse empty? :param [pr se [var hair_var =] (word ",:what ". :dot "\(\) )][
                pr se [var hair_var =] (word ",:what ". :dot "\( hair.module.node.param :param "\) )
            ]
        ]
        pr [hair_fs.writeFileSync("module_temp.htxt", hair_var)]
        pr [hair_fs.writeFileSync("module_temp_end.htxt", "")]
        setwrite []
        close "module_temp.js
        ignore shell [cmd /c node module_temp.js]
        until [member? "module_temp_end.htxt files] [wait 1]
        erf "module_temp.js
        erf "module_temp_end.htxt
        openread "module_temp.htxt
        setread "module_temp.htxt
        localmake "_out readrawline
        setread []
        close "module_temp.htxt
        erf "module_temp.htxt
        op :_out
    ]
][
    if :exist = 0 [
        hair.debug.error [module is not existed.]
    ]
]


hair.module.switch last thing word "hair_module_handshake_ :_id
hair.module.case "value [make :what first thing word "hair_module_handshake_ :_id]
hair.module.case "procedure [copydef :what first thing word "hair_module_handshake_ :_id]
hair.module.case "class [if not equal? :what first thing word "hair_module_handshake_ :_id [new :what "class .inherit first thing word "hair_module_handshake_ :_id]]

er word "hair_module_handshake_ :_id
make "hair_module_handshake bl :hair_module_handshake
end 

to hair.module.out :what :type
ifelse member? :type [value procedure class] [make word "hair_module_handshake_ last :hair_module_handshake list :what :type] [hair.debug.error [wrong module type]]
end

to hair.module.node.param :list
if not list? :list [op (word "\" :list "\")]
localmake "_param "
foreach :list [make "_param (word :_param "\" ? "\", )]
op bl :_param
end

;------- oop.lgo ---------
make "attr_temp "
make "method_temp "
make "listen_temp "
make "beaf_temp "
to hair.object.class :name
if or (member? :name :hair_object_list) (member? :name :hair_object_class) [hair.debug.error se :name [aleady exists.] stop]
if member? :name :hair_keepword [hair.debug.error (se "classname :name [is illegal.]) stop]
define word :name ". hair.object.replace :name [[][(hair.object.refresh __name "class) op [.attr .method .before .after .listen .inherit]]] 3
define :name [[][hair.debug.error [You cannot use CLASS like this.]]]
queue "hair_object_class :name
define word :name ".attr hair.object.replace :name [[varlist][(hair.object.refresh __name "class) pprop word "hair_object_class_ __name "attr :varlist]] 3
if not member? "attr :hair_object_havedefine [define ".attr [[][]] queue "hair_object_havedefine "attr]
define word :name ".before hair.object.replace :name [[command][(hair.object.refresh __name "class) pprop word "hair_object_class_ __name "before :command]] 3
if not member? "before :hair_object_havedefine [define ".before [[][]] queue "hair_object_havedefine "before]
define word :name ".after hair.object.replace :name [[command][(hair.object.refresh __name "class) pprop word "hair_object_class_ __name "after :command]] 3
if not member? "after :hair_object_havedefine [define ".after [[][]] queue "hair_object_havedefine "after]
define word :name ".listen hair.object.replace :name [[var command][(hair.object.refresh __name "class) pprop word "hair_object_class_ __name "listen lput :var gprop word "hair_object_class_ __name "listen
  pprop word "hair_object_class_ __name :var :command]] 3
if not member? "listen :hair_object_havedefine [define ".listen [[][]] queue "hair_object_havedefine "listen]
define word :name ".method hair.object.replace :name [[var command][(hair.object.refresh __name "class) pprop word "hair_object_class_ __name "method lput :var gprop word "hair_object_class_ __name "method
  pprop word "hair_object_class_ __name :var :command]] 3
if not member? "method :hair_object_havedefine [define ".method [[][]] queue "hair_object_havedefine "method]
define word :name ".inherit hair.object.replace :name [[class][(hair.object.refresh __name "class) pprop word "hair_object_class_ __name "inherit :class]] 3
if not member? "inherit :hair_object_havedefine [define ".inherit [[][]] queue "hair_object_havedefine "inherit]
(hair.object.refresh :name "class)
hair.hook.bind "hair_exit se "bury quoted :name
hair.hook.bind "hair_exit se "bury quoted word :name ".
hair.hook.bind "hair_exit se "bury quoted word :name ".attr
hair.hook.bind "hair_exit se "bury quoted word :name ".before
hair.hook.bind "hair_exit se "bury quoted word :name ".after
hair.hook.bind "hair_exit se "bury quoted word :name ".listen
hair.hook.bind "hair_exit se "bury quoted word :name ".method
hair.hook.bind "hair_exit se "bury quoted word :name ".inherit
end
to hair.object.classp :name
if member? :name :hair_object_class [op "true]
op "false
end
to hair.object.destroy :name
if not member? :name :hair_object_list [hair.debug.error "对象名不存在 stop]
if name? (word "hair_object_ :name "_after) [
  localmake "_cancel 0
  catch "cancel [run thing (word "hair_object_ :name "_after) make "_cancel 1]
  if :_cancel = 0 [stop]
  ]
make "hair_object_list remove :name :hair_object_list
ern (word "hair_object_ :name "_after)
er :name
localmake "tip_temp thing (word "hair_object_ :name "_tip)
repeat count :tip_temp [
  ;与regdot一一对应，首先删除属性的实际变量，此版本不考虑简化过程的问题
  ern (word "hair_object_ :name "_ bf item repcount :tip_temp)
  ;删除输出变量或方法内容的过程
  er (word :name item repcount :tip_temp)
  ;删除赋值过程
  er (word :name item repcount :tip_temp ".value)
  er (word :name item repcount :tip_temp ".val)
  ;删除输出修改前变量内容的过程
  er (word :name item repcount :tip_temp ".h)
  ;删除取消属性变动的cancel过程
  er (word :name item repcount :tip_temp ".cancel)
]
ern (word "hair_object_ :name "_tip)
bury word :name ".
end
to cancel
throw "cancel
end
to hair.object.new :name :class
if :class = "Class [hair.object.class :name stop]
if or member? :name :hair_object_list procedure? :name [hair.debug.error [objname aleady exists.] stop]
if member? :name :hair_keepword [hair.debug.error [objname is illegal] stop]
if not proplist? word "hair_object_class_ :class [hair.debug.error (se "Class :class [does not exist.]) stop]
make (word "hair_object_ :name "_tip) []
define word :name ". hair.object.replace :name [[][hair.object.refresh __name pr hair.debug.tool.repeat3 thing (word "hair_object_ __name "_tip)]] 3 
queue (word "hair_object_ :name "_tip) ".objname
queue (word "hair_object_ :name "_tip) ".class
define word :name ".objname hair.object.replace :name [[][hair.object.refresh __name op __name]] 3
define word :name ".class hair.object.replace :name [[][hair.object.refresh __name op __x]] se 3 :class
if not member? "objname :hair_object_havedefine [define ".objname [[][]] queue "hair_object_havedefine "objname]
if not member? "class :hair_object_havedefine [define ".class [[][]] queue "hair_object_havedefine "class]
define :name [[][hair.debug.error [You cannot use object like this.]]]
make "attr_temp []
make "method_temp []
make "listen_temp []
make "beaf_temp []
findinherit :class
make "beaf_temp hair.object.replace :name :beaf_temp 1
make "method_temp hair.object.replace :name :method_temp 1
make "listen_temp hair.object.replace :name :listen_temp 1
repeat (count :attr_temp)/2 [hair.object.regdot :name item repcount*2-1 :attr_temp item repcount*2 :attr_temp 1]
localmake "_cancel 0
catch "cancel [run first :beaf_temp make "_cancel 1]
if :_cancel = 0 [
  ' [因为cancel抛出而删除之前创建的属性]
  ' [1.删除tip变量和xx.过程]
  ' [bury se word ("hair_object_ :name "_tip) word :name ".]
  ' [2.删除objname和class属性以及其他属性]
  ' [3.移除对象过程和取消挂载]
  hair.object.destroy :name stop
]
queue "hair_object_list :name
repeat (count :method_temp)/2 [hair.object.regdot :name item repcount*2-1 :method_temp item repcount*2 :method_temp 2]
make (word "hair_object_ :name "_after) last :beaf_temp
repeat (count :listen_temp)/2 [hair.hook.bind (word :name ". item repcount*2-1 :listen_temp "_onchange) se [catch "cancel] (list se [run] (list item repcount*2
  hair.object.replace :name :listen_temp se 2 (word :name ". item repcount*2-1 :listen_temp ".cancel)))]
hair.object.refresh :name
end
to findinherit :curclass
if member? "inherit replaceattr2 plist word "hair_object_class_ :curclass [findinherit gprop word "hair_object_class_ :curclass "inherit]
localmake "attr_cur gprop word "hair_object_class_ :curclass "attr
replaceattr :attr_cur replaceattr2 :attr_temp
localmake "method_cur gprop word "hair_object_class_ :curclass "method
replacemethod :method_cur replaceattr2 :method_temp :curclass
localmake "listen_cur gprop word "hair_object_class_ :curclass "listen
replacelisten :listen_cur replaceattr2 :listen_temp :curclass
if empty? :beaf_temp [make "beaf_temp [[][]]]
make "beaf_temp list (se gprop word "hair_object_class_ :curclass "before first :beaf_temp) (se gprop word "hair_object_class_ :curclass "after last :beaf_temp)
end
to replacemethod :cur :temp :class
if empty? :cur [stop]
ifelse not member? first :cur :temp [make "temp se :temp first :cur make "method_temp (se :method_temp first :cur (list gprop word "hair_object_class_ :class first :cur))] [
  localmake "index_temp hair.base.index first :cur :temp
  make "method_temp (se hair.base.getitem :index_temp*2-1 :method_temp (list gprop word "hair_object_class_ :class first :cur) hair.base.delitem :index_temp*2 :method_temp)]
replacemethod bf :cur :temp :class
end
to replacelisten :cur :temp :class
if empty? :cur [stop]
ifelse not member? first :cur :temp [make "temp se :temp first :cur make "listen_temp (se :listen_temp first :cur (list gprop word "hair_object_class_ :class first :cur))] [
  localmake "index_temp hair.base.index first :cur :temp
  make "listen_temp (se hair.base.getitem :index_temp*2-1 :listen_temp (list gprop word "hair_object_class_ :class first :cur) hair.base.delitem :index_temp*2 :listen_temp)]
replacelisten bf :cur :temp :class
end
to replaceattr :cur :temp
if empty? :cur [stop]
ifelse not member? first :cur :temp [make "temp se :temp first :cur make "attr_temp se :attr_temp hair.base.getitem 2 :cur] [
  localmake "index_temp hair.base.index first :cur :temp
  make "attr_temp (se hair.base.getitem :index_temp*2-1 :attr_temp (list first bf :cur) hair.base.delitem :index_temp*2 :attr_temp)]
replaceattr bf bf :cur :temp
end
to replaceattr2 :temp
op hair.object.even :temp
end
to hair.object.even :temp
if 2 > count :temp [op :temp]
op filter [equal? remainder # 2 1] :temp
end
to hair.object.p :name
if member? :name :hair_object_list [op "true]
op "false
end
to hair.object.refresh :name [:type "object]
if not :name = "hair_object_current [
  make "hair_object_current :name
  ifelse :type = "object [localmake "_ref thing (word "hair_object_ :name "_tip)][localmake "_ref [.attr .method .before .after .listen .inherit]]
  repeat count :_ref [copydef item repcount :_ref word :name item repcount :_ref]
  ;foreach run word :name ". [copydef ? word :name ?]
]
end
to hair.object.regdot :name :x :content :type
if and (not member? :x [class objname]) member? :x :hair_keepword [hair.debug.error [The name of attr or method is illegal.] stop]
queue (word "hair_object_ :name "_tip) word ". :x
if :type = 1 [queue (word "hair_object_ :name "_tip) (word ". :x ".val)
  queue (word "hair_object_ :name "_tip) (word ". :x ".value)]
ifelse :type = 1 [
  ;创建一个对应的实际变量
  make (word "hair_object_ :name "_ :x) :content
  ;定义直接输出变量内容的过程
  define (word :name ". :x) hair.object.replace :name [[][hair.object.refresh __name op thing (word "hair_object_ __name "_ __x )]] se 3 :x
  ;定义value和val用于赋值，在此处应该考虑保留钩子触发listen
  define (word :name ". :x ".value) hair.object.replace :name [[val][hair.object.refresh __name
    ;保存修改前的变量内容
    localmake "value run (word __name ". __x )
    if word? :value [define (word __name ". __x ".h) list [] se [op] quoted :value]
    if list? :value [define (word __name ". __x ".h) list [] se [op] (list :value)]
    ;真正进行变量替换
    make (word "hair_object_ __name "_ __x ) :val
    ;在替换完之后触发钩子，cancel即为还原值
    hair.hook.create (word __name ". __x "_onchange)
  ]] se 3 :x
  copydef (word :name ". :x ".val) (word :name ". :x ".value)
  ;定义属性变动的cancel过程
  define (word :name ". :x ".cancel) hair.object.replace :name [[][make (word "hair_object_ __name "_ __x ) run (word __name ". __x ".h) throw "cancel]] se 3 :x
][
  ;替换掉content中的this，这里面通常不会出现cancel
  make "content hair.object.replace :name :content 1
  ifelse not empty? :content [ifelse list? first :content [define (word :name ". :x) list first :content (se [hair.object.refresh] quoted :name last :content)]
    [define (word :name ". :x) list [] (se [hair.object.refresh] quoted :name :content)]][
    define (word :name ". :x) list [] (se [hair.object.refresh] quoted :name :content)]
]
if not member? :x :hair_object_havedefine [define word ". :x [[][]] queue "hair_object_havedefine :x]
if and :type=1 not member? word :x ".value :hair_object_havedefine [define (word ". :x ".value) [[][]] define (word ". :x ".val) [[][]] queue "hair_object_havedefine word :x ".value]
end
to hair.object.replace :objname :string :type
if number? :string [op :string]
if word? :string [op hair.object.replace.repeat :objname :string :type]
op hair.object.replace.foreach :objname [] :string :type
end
to hair.object.replace.foreach :objname :left :right :type
if empty? :right [op :left]
localmake "center first :right
local "temp
if number? :center [make "temp :center]
if list? :center [make "temp hair.object.replace.foreach :objname [] :center :type]
if word? :center [make "temp hair.object.replace.repeat :objname :center :type]
op hair.object.replace.foreach :objname se :left (list :temp) bf :right :type
end
to hair.object.replace.repeat :objname :value :type
if :type=1 [if :value = "this [op :objname]
  if :value = quoted "this [op quoted :objname]
  if :value = first [(this] [op word first [(] :objname]
  if :value = first [this)] [op word :objname first [)]]
  if (count :value)>4 [if "this. = hair.base.getitem 5 :value [op (word :objname ". hair.base.delitem 5 :value)]
	if (quoted "this.) = hair.base.getitem 6 :value [op (word quoted :objname ". hair.base.delitem 6 :value)]
  ]]
if and (first :type)=2 :value="cancel [op last :type]
if and (first :type)=3 :value="__name [op QUOTED :objname]
if and (first :type)=3 :value = "__x [op quoted last :type]
op :value
end
to hair.object.select :class
localmake "currentrestore :hair_object_current
localmake "classall []
repeat count :hair_object_list [queue "classall run (list word item repcount :hair_object_list ".class)]
ifelse member? :currentrestore :hair_object_list [hair.object.refresh :currentrestore] [(hair.object.refresh :currentrestore "class)]
localmake "objall []
repeat count :classall [if (item repcount :classall) = :class [queue "objall repcount]]
make "classall []
repeat count :objall [queue "classall item (item repcount :objall) :hair_object_list]
op :classall
end
;------- noconflict.lgo ---------
to hair.noconflict :symbol
make "hair_symbol :symbol
localmake "s :symbol
catch "error [copydef         "hook          "hair.hook.bind     ];--hook :a.. :c..      绑定钩子函数
catch "error [copydef         "destroy       "hair.object.destroy];--destroy :name       销毁对象
catch "error [copydef         "new           "hair.object.new    ];--new :name :class    根据类创建对象
catch "error [copydef         "'             "hair.debug.'       ];--' :a                框架注释留用
catch "error [copydef         "module.in     "hair.module.in     ];--module.in :a :path  载入指定模块
catch "error [copydef         "module.out    "hair.module.out    ];--module.out :v :type 模块文件暴露接口
catch "error [copydef word :s "noconflict    "hair.noconflict    ];--$noconflict :symbol 简化框架中的基础命令
catch "error [copydef word :s "aget          "hair.old.aget      ];--$aget :a :v         设定数组的值
catch "error [copydef word :s "array         "hair.old.array     ];--$array :v           创建数组
catch "error [copydef word :s "aset          "hair.old.aset      ];--$aset :a :v :c      读取数组的值
catch "error [copydef word :s "bm            "remove             ];--$bm :a :b           删除指定元素
catch "error [copydef word :s "setfont       "hair.old.setfont   ];--$setfont :f.. :s..  设定字体字号
catch "error [copydef word :s "tt            "hair.old.tt        ];--$tt :text           在屏幕上输出内容
catch "error [copydef word :s "allfiles      "hair.base.allfiles ];--$allfiles           输出当前目录下所有文件
catch "error [copydef word :s "arraysize     "hair.base.arraysize];--$arraysize :a       输出数组的大小
catch "error [copydef word :s "asc           "hair.base.asc      ];--$asc :list          升序排列一个表(无重复)
catch "error [copydef word :s "bmitem        "hair.base.bmitem   ];--$bmitem :n :v       删除表或字中指定位置的元素
catch "error [copydef word :s "copyfile      "hair.base.copyfile ];--$copyfile :n1 :n2   复制文件
catch "error [copydef word :s "curosr        "hair.base.curosr   ];--$cursor :cur_name   控制鼠标光标形状和隐现
catch "error [copydef word :s "delitem       "hair.base.delitem  ];--$delitem :n :v      去除变量的前几位
catch "error [copydef word :s "desc          "hair.base.desc     ];--$desc :list         倒序排列一个表(无重复)
catch "error [copydef word :s "getitem       "hair.base.getitem  ];--$getitem :n :v      获取变量的前几位
catch "error [copydef word :s "hex2rgb       "hair.base.hex2rgb  ];--$hex2rgb :h :r      16进制颜色转rgb格式
catch "error [copydef word :s "index         "hair.base.index    ];--$index :v :list     获取元素在表中第一次出现的位置
catch "error [copydef word :s "logoxy        "hair.base.logoxy   ];--$logoxy :xy         转化坐标为原始logo坐标
catch "error [copydef word :s "makem         "hair.base.makem    ];--$makem :v           变量自减一
catch "error [copydef word :s "makep         "hair.base.makep    ];--$makep :v           变量自加一
catch "error [copydef word :s "match         "hair.base.match    ];--$match :v1 :v2      正则匹配
catch "error [copydef word :s "max           "hair.base.max      ];--$max :list          取数字表中的最大值
catch "error [copydef word :s "merge         "hair.base.merge    ];--$merge :v1 :v2      汇总字表
catch "error [copydef word :s "min           "hair.base.min      ];--$min :list          取数字表中的最小值
catch "error [copydef word :s "mousexy       "hair.base.mousexy  ];--$mousexy            输出以左上角为原点的鼠标位置
catch "error [copydef word :s "random        "hair.base.random   ];--$random :s :e       输出起止点之间的某个实数支持小数
catch "error [copydef word :s "rename        "hair.base.rename   ];--$rename :n1 :n2     重命名文件
catch "error [copydef word :s "first         "hair.base.safefirst];--$first :xx          安全的取字表的第一个值
catch "error [copydef word :s "last          "hair.base.safelast ];--$last :xx           安全的取字表的最后一个值
catch "error [copydef word :s "screenxy      "hair.base.screenxy ];--$screenxy :xy       转化坐标为屏幕坐标
catch "error [copydef word :s "shell         "hair.base.shell    ];--$shell :l :callback 文件方式执行一段shell语句
catch "error [copydef word :s "title         "hair.base.settitle ];--$title :text        设置主窗口标题
catch "error [copydef word :s "token         "hair.base.token    ];--$token :l           生成随机数字字母字符串
catch "error [copydef word :s "turtlefree    "hair.base.turtlefree ];--$turtlefree       获取一个空闲的海龟编号
catch "error [copydef word :s "whatdir       "hair.base.whatdir  ];--$whatdir            获取当前目录
catch "error [copydef word :s "class?        "hair.object.classp ];--$class? :name       判断字符串是否为类
catch "error [copydef word :s "object?       "hair.object.p      ];--$object? :name      判断字符串是否为对象
catch "error [copydef word :s "select        "hair.object.select ];--$select :class      输出所有指定类型的对象
catch "error [copydef word :s "hookclear     "hair.hook.clear    ];--$hookclear :a..     清空指定钩子绑定的内容
catch "error [copydef word :s "hookcreate    "hair.hook.create   ];--$hookcreate :a..    注册钩子指令
catch "error [copydef word :s "drawpic       "hair.resource.drawpic   ];--$drawpic :n    显示图片资源文件
catch "error [copydef word :s "drawpicwithmask "hair.resource.drawpicwithmask];:i1 :i2   显示带遮罩的透明图片
catch "error [copydef word :s "getpicid      "hair.resource.getpicid  ];--$getpicid :n   通过载入的图片名称获取id
catch "error [copydef word :s "loadpic       "hair.resource.loadpic   ];--$loadpic :i    载入图片资源文件
catch "error [copydef word :s "restart       "hair.debug.restart ];--$restart            重启调试
catch "error [copydef word :s "tool          "hair.debug.tool    ];--$tool               hair开发者工具
catch "error [copydef word :s "async         "hair.background.async   ];--$async :c      异步执行语句
catch "error [copydef word :s "hook          "hair.hook.bind     ];--$hook == hook
catch "error [copydef word :s "destroy       "hair.object.destroy];--$destroy == destroy
catch "error [copydef word :s "new           "hair.object.new    ];--$new == new
catch "error [copydef word :s "objectp       "hair.object.p      ];--$objectp == $object?
catch "error [copydef word :s "classp        "hair.object.classp ];--$classp == $class?
catch "error [copydef word :s "case         "hair.module.case    ];--$case :a            类似其他的case语句
catch "error [copydef word :s "idgen        "hair.module.idgen   ];--$idgen              输出一个全局唯一id
catch "error [copydef word :s "position     "hair.base.index     ];--$position :a :b     输出a在b中的位置
catch "error [copydef word :s "switch       "hair.module.switch  ];--$switch :a          类似其他的switch语句
catch "error [copydef word :s "compressdir  "hair.file.compressdir];-$compressdir :a :b  压缩一个目录
catch "error [copydef word :s "extension    "hair.file.extension ];--$extension :a       目录下指定扩展名的文件
end
to hair.noconflict.repeat :list
localmake "s :hair_symbol
repeat count :list [catch "error [copydef word :s first (item repcount :list) last (item repcount :list)]]
end
;------- resource.lgo ---------
to hair.resource.drawpic :i
localmake "restore BITINDEX
SETBITINDEX :i
bitpaste
SETBITINDEX :restore
end
to hair.resource.drawpicwithmask :i1 :i2
if :i2=0 [stop]
localmake "__restore BITINDEX
SETBITINDEX :i1
localmake "__bitsize bitsize
setbitindex :hair_resource_piclimit
bitcopy first :__bitsize last :__bitsize
setbitindex :i2
setbitmode 3
bitpastetoindex :hair_resource_piclimit 0 0
setbitindex :i1
setbitmode 2
bitpastetoindex :hair_resource_piclimit 0 0
setbitindex :hair_resource_piclimit
setbitmode 1
bitpaste
SETBITINDEX :__restore
end
to hair.resource.getpicid :n
op last item hair.base.index :n firsts :hair_resource_picidlist :hair_resource_picidlist
end
to hair.resource.loadpic :n
localmake "restore BITINDEX
hair.base.rename word :n ".hpic word :n ".bmp
SETBITINDEX :hair_resource_piclimit
localmake "size bitloadsize word :n ".bmp
ask 39 [bitload word :n ".bmp]
ask 39 [bitcut first :size last :size]
SETBITINDEX :restore
hair.base.rename word :n ".bmp word :n ".hpic
queue "hair_resource_picidlist se :n :hair_resource_piclimit
make "hair_resource_piclimit :hair_resource_piclimit + 1
op :hair_resource_piclimit - 1
end
