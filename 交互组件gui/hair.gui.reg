;hair内置模块
;实现gui的各类组件及交互功能
;命令版本号v1.3

to hair.gui.reg
make "hair.gui_require 1.3
make "hair.gui_noconflict [[inrange hair.gui.inrange][getkey hair.gui.getkey][keyp hair.gui.keyp][key? hair.gui.keyp][polygon hair.gui.polygon][spiral hair.gui.spiral]]
make "hair_gui_listenkey "false ;默认不启用键盘监听
make "hair_gui_listenmouse "true ;默认启用鼠标监听
make "hair_gui_keylock " ;使hair框架中组件得以独享键盘信息
make "hair_gui_keybuffer [] ;键盘按键缓存
make "hair_gui_stillhover 1 ;鼠标hover性能
make "hair_gui_scenebackground hair.base.turtlefree ;获取一只海龟画场景的背景
make "hair_gui_scene " ;当前的场景
hook "hair_exit [buryname [hair_gui_scenebackground hair_gui_stillhover hair_gui_keybuffer _hair_gui_listenkey hair_gui_curhover _guicurhover hair_gui_curpress _guicurpress hair_gui_curclick _guicurclick hair_gui_scene hair_gui_listenkey hair_gui_listenmouse hair_gui_keylock]]
chdir :hair_res
ifelse :hair_debug [pr "载入hair.gui资源文件中...] [windowset "FMSLogo 0 WINDOWCREATE "main "waitwindow "请稍候 300 200 120 100 []
	STATICCREATE "waitwindow "message [正在加载资源文件...] 25 25 70 25 windowenable "waitwindow "false]
make "_nothing (se $loadpic "btn_normal_mask $loadpic "btn_normal_normal_wait $loadpic "btn_normal_normal_hover $loadpic "btn_normal_normal_press $loadpic "btn_normal_normal_click $loadpic "btn_normal_modern_wait $loadpic "btn_normal_modern_hover $loadpic "btn_normal_modern_press $loadpic "btn_normal_modern_click) ;按钮的图片资源
if not :hair_debug [WINDOWDELETE "waitwindow windowset "FMSLogo 1]
popdir

;负责响应鼠标移动行为，即判断哪一个画布得到hover状态
hook "hair_gui_mousehover [
	make "hair_gui_curhover "
	catch "findwhichhover [foreach run word :hair_gui_scene ".canvas [
		make "_guicurhover ?
		if hair.gui.inrange mousepos hair.base.logoxy se run word :_guicurhover ".xpos run word :_guicurhover ".ypos run word :_guicurhover ".width run word :_guicurhover ".height [make "hair_gui_curhover :_guicurhover throw "findwhichhover]
	]]
	' [如果没有任何画布被hover，则状态全部坍缩为wait]
	' [某个画布被hover，其他画布变为wait，该画布为press时，状态不变，hover不变，不可能是click，仅当为wait的时候变成hover]
	ifelse empty? :hair_gui_curhover [
		if :hair_gui_stillhover = 0 [
			foreach run word :hair_gui_scene ".canvas [run se word ? ".mousestatus.val quoted "wait]
			make "hair_gui_stillhover 1
		]
	] [
		make "hair_gui_stillhover 0
		foreach remove :hair_gui_curhover run word :hair_gui_scene ".canvas [run se word ? ".mousestatus.val quoted "wait]
		if "wait = run word :hair_gui_curhover ".mousestatus [run se word :hair_gui_curhover ".mousestatus.val quoted "hover]
	]
]
;负责响应鼠标的按下行为，即判断哪个画布得到press状态
hook "hair_gui_mousepress [
	ifelse empty? :hair_gui_curhover [
	make "hair_gui_curpress "
	catch "findwhichpress [foreach run word :hair_gui_scene ".canvas [
		make "_guicurpress ?
		if hair.gui.inrange mousepos hair.base.logoxy se run word :_guicurpress ".xpos run word :_guicurpress ".ypos run word :_guicurpress ".width run word :_guicurpress ".height [make "hair_gui_curpress :_guicurpress throw "findwhichpress]
	]]][make "hair_gui_curpress :hair_gui_curhover]
	' [鼠标不在任何画布中，即表示随便乱点的，不做操作]
	' [在某个画布中按下，画布状态不可能click，不可能是press，极小概率wait，hover改为press]
	ifelse empty? :hair_gui_curpress [
	] [
		if member? run word :hair_gui_curpress ".mousestatus [wait hover] [run se word :hair_gui_curpress ".mousestatus.val quoted "press]
	]
]
;负责响应鼠标的松开行为，即判断哪个画布得到click状态
hook "hair_gui_mouseclick [
	ifelse empty? :hair_gui_curhover [
	make "hair_gui_curclick "
	catch "findwhichclick [foreach run word :hair_gui_scene ".canvas [
		make "_guicurclick ?
		if hair.gui.inrange mousepos hair.base.logoxy se run word :_guicurclick ".xpos run word :_guicurclick ".ypos run word :_guicurclick ".width run word :_guicurclick ".height [make "hair_gui_curclick :_guicurclick throw "findwhichclick]
	]]][make "hair_gui_curclick :hair_gui_curhover]
	' [鼠标不在任何画布中，即表示随便乱点的，不做操作]
	' [在某个画布中松开，画布状态必须为press，才产生一次click，然后回到hover]
	ifelse empty? :hair_gui_curclick [
	] [
		if "press = run word :hair_gui_curclick ".mousestatus [run se word :hair_gui_curclick ".mousestatus.val quoted "click run se word :hair_gui_curclick ".mousestatus.val quoted "hover]
	]
]

new "hair_timer_keyboard "Timer
	.delay.value 10
	.mode.value "noyield
	.command.value [if not (or empty? :hair_gui_scene not :hair_gui_listenkey) [hair.hook.create "hair_gui_key]]
	.start

hook "hair_gui_key [
	if hair.gui.keyp [
		make "_curkey hair.gui.getkey
		ifelse empty? :hair_gui_keylock [
			make "_scenekey run word :hair_gui_scene ".key
			do.until [ifelse :_curkey=first :_scenekey [run hair.object.replace first bf :_scenekey first bf bf :_scenekey 1 make "_scenekey []] [make "_scenekey bf bf bf :_scenekey]] [empty? :_scenekey]
		][
			run se word :hair_gui_keylock ".keyall :_curkey
		]
	]
]

;创建场景类，用来统一管理画布元素
new "Scene "Class
.attr [canvas [] key [] background [hair.old.tt "Scene]] ;此场景中容纳的元素，一个元素仅可以被一个场景调用,key[67 Button1 [wakka] 68 Button1 [] 69 Button2 []]
.method "render [make "hair_gui_keybuffer [] make "hair_gui_listenmouse "false make "_hair_gui_listenkey :hair_gui_listenkey make "hair_gui_listenkey "false cs ask :hair_gui_scenebackground [ht pu setpos hair.base.logoxy [0 0] pd run this.background] make "hair_gui_scene this.objname
	foreach this.canvas [make "_sceneitem ? run se word :_sceneitem ".keepback.val 0 if run word :_sceneitem ".display [run word :_sceneitem "._render]]
	make "hair_gui_listenmouse "true make "hair_gui_listenkey :_hair_gui_listenkey
	mouseon [if not (or empty? :hair_gui_scene not :hair_gui_listenmouse) [hair.hook.create "hair_gui_mousepress]][if not (or empty? :hair_gui_scene not :hair_gui_listenmouse) [hair.hook.create "hair_gui_mouseclick]][][][if not (or empty? :hair_gui_scene not :hair_gui_listenmouse) [hair.hook.create "hair_gui_mousehover]]
	keyboardon [queue "hair_gui_keybuffer keyboardvalue]] ;切换到该场景，清空之前场景的所有数据、元素和键鼠交互检测
.method "collision [[xy wd canvas][localmake "newcanvas remove :canvas this.canvas repeat count :newcanvas [make "_sceneitem item repcount :newcanvas
	if run word :_sceneitem ".display [
		if not hair.gui.collision hair.base.logoxy :xy :wd hair.base.logoxy se run word :_sceneitem ".xpos run word :_sceneitem ".ypos se run word :_sceneitem ".width run word :_sceneitem ".height [op "false]]] op "true ]] ;判断传递的参数与该场景内的其他显性元素之间是否冲突
.method "addcanvas [[canvas][this.canvas.val se this.canvas :canvas]] ;给canvas初始化方法调用
.method "addapply [[apply canvas command][this.key.val (se this.key :apply :canvas (list :command))]]

;创建画布类，画布采用左上角为原点的坐标系
new "Canvas "Class
.attr [width 100 height 100 xpos 0 ypos 0 display true scene 0 draw [pu setxy xcor+1 ycor-1 pd repeat 2 [rt 90 fd this.width - 2 rt 90 fd this.height - 2] SETFLOODCOLOR 4 pu setxy xcor+1 ycor-1 pd fill hair.old.tt this.mousestatus] keepback 0 turtle 0 mousestatus wait noflicker false]
.before [this.turtle.val hair.base.turtlefree] ;创建画布时获取一个空闲海龟
.listen "width [if this.width = this.width.h [cancel] if and this.scene = :hair_gui_scene this.display = "true [ifelse not run se word this.scene ".collision se list se this.xpos this.ypos se this.width this.height quoted this.objname [hair.debug.error _e "位置冲突 cancel] [( this._render se this.xpos this.ypos se this.width.h this.height )]]]
.listen "height [if this.height = this.height.h [cancel] if and this.scene = :hair_gui_scene this.display = "true [ifelse not run se word this.scene ".collision se list se this.xpos this.ypos se this.width this.height quoted this.objname [hair.debug.error _e "位置冲突 cancel] [( this._render se this.xpos this.ypos se this.width this.height.h )]]]
.listen "xpos [if this.xpos = this.xpos.h [cancel] if and this.scene = :hair_gui_scene this.display = "true [ifelse not run se word this.scene ".collision se list se this.xpos this.ypos se this.width this.height quoted this.objname [hair.debug.error _e "位置冲突 cancel] [( this._render se this.xpos.h this.ypos se this.width this.height )]]]
.listen "ypos [if this.ypos = this.ypos.h [cancel] if and this.scene = :hair_gui_scene this.display = "true [ifelse not run se word this.scene ".collision se list se this.xpos this.ypos se this.width this.height quoted this.objname [hair.debug.error _e "位置冲突 cancel] [( this._render se this.xpos this.ypos.h se this.width this.height )]]]
.listen "display [if this.display = this.display.h [cancel] if and this.scene = :hair_gui_scene this.display = "true [ifelse not run se word this.scene ".collision se list se this.xpos this.ypos se this.width this.height quoted this.objname [hair.debug.error _e "位置冲突 cancel] [( this._render se this.xpos this.ypos se this.width this.height )]]]
.listen "draw [if this.draw = this.draw.h [cancel] if and this.scene = :hair_gui_scene this.display = "true [this._render]]
.method "move [[xypos][if not list? :xypos [hair.debug.error _e "移动画布需要xy坐标组成的表作为参数 stop] this.xpos.val first :xypos this.ypos.val last :xypos]]
.method "show [if this.display = "true [stop] this.display.val "true]
.method "hide [if this.display = "false [stop] this.display.val "false]
.method "init [[scene][if not this.scene = 0 [hair.debug.error _e "不能重复初始化画布 stop] if not member? :scene $select "scene [hair.debug.error _e "场景不存在 stop] run se word :scene ".addcanvas quoted this.objname this.scene.val :scene]] ;初始化登记画布到某个场景中
if :hair_debug [.listen "mousestatus [if this.mousestatus = "click [pr "clicked] if not this.mousestatus = this.mousestatus.h [( this._render se this.xpos this.ypos se this.width this.height )]]]
.method "key [[apply command][if this.scene = 0 [hair.debug.error _e "请先初始化画布 stop] run (se (word this.scene ".addapply) :apply quoted this.objname (list :command))]] ;向场景登记画布需要检测的按键以及需要执行的语句
.method "keyall [[key][pr :key]] ;当本画布锁定键盘监听的时候遇到键盘输入事件此方法被调用
.method "_reset [( this._render se this.xpos this.ypos se this.width this.height )]
.method "_render [[[xy []] [wh []]][if not :hair_gui_scene = this.scene [stop]
	if not this.keepback = 0 [
		if not this.noflicker [setbitindex this.keepback ask this.turtle [pu setpos hair.base.logoxy se first :xy (last :xy) + last :wh pd localmake "restore bitindex setbitindex this.keepback bitpaste setbitindex :restore]]
	]
	if not this.display [ask this.turtle [pu setpos hair.base.logoxy se this.xpos this.ypos pd] stop]
	ask this.turtle [ht pu setpos hair.base.logoxy se this.xpos this.ypos + this.height pd]
	if this.keepback = 0 [this.keepback.val :hair_resource_piclimit hair.base.makep "hair_resource_piclimit localmake "restore bitindex setbitindex this.keepback ask this.turtle [bitcopy this.width this.height] setbitindex :restore]
	if not this.noflicker [localmake "restore bitindex setbitindex this.keepback ask this.turtle [bitcopy this.width this.height] setbitindex :restore]
	ask this.turtle [pu setpos hair.base.logoxy se this.xpos this.ypos pd run hair.object.replace this.objname this.draw 1 pu setpos hair.base.logoxy se this.xpos this.ypos pd]
]]
;noflicker用来解决闪烁问题，即不贴原图，直接用新图覆盖的办法，场景局限在draw的前后范围必须完美相同

;继承画布类的图片画布，解决透明问题
new "PicCanvas "Class
.inherit "Canvas
.listen "pic [make "restore bitindex setbitindex this.pic this.width.val 2+first bitsize this.height.val 2+last bitsize setbitindex :restore]
.attr [draw [pu setpos hair.base.logoxy se this.xpos + 1 this.ypos + this.height - 1 pd hair.resource.drawpicwithmask this.pic this.mask] pic 0 mask 0]
.listen "width []
.listen "height []

;创建按钮类继承画布类
new "Button "Class
.inherit "PicCanvas
ifelse :hair_debug [.attr [text 按钮 size normal style normal hotkey 0 click [pr "click] press [this.text.val "press] hover [this.text.val "hover] wait [this.text.val "wait] noflicker true draw [pu setpos hair.base.logoxy se this.xpos + 1 this.ypos + this.height - 1 pd
	hair.resource.drawpicwithmask this.pic this.mask pu setpos hair.base.logoxy se this.xpos + ( this.width - first labelsize this.text )/2 this.ypos + ( this.height - last labelsize this.text )/2 pd if this.style = "normal [setpencolor "white] hair.old.tt this.text setpencolor "black]]][
	.attr [text 按钮 size normal style normal hotkey 0 click [] press [] hover [] wait [] noflicker true draw [pu setpos hair.base.logoxy se this.xpos + 1 this.ypos + this.height - 1 pd
		hair.resource.drawpicwithmask this.pic this.mask pu setpos hair.base.logoxy se this.xpos + ( this.width - first labelsize this.text )/2 this.ypos + ( this.height - last labelsize this.text )/2 pd if this.style = "normal [setpencolor "white] hair.old.tt this.text setpencolor "black]]
	]
.before [this.pic.val 41 this.mask.val 40 this.width.val 94 this.height.val 39]
.listen "hotkey [this.key this.hotkey [this.mousestatus.val "click this.mousestatus.val "hover]]
.listen "size [if not this.keepback = 0 [cancel] this.pic.val hair.resource.getpicid (word "btn_ this.size "_ this.style "_wait) this.mask.val hair.resource.getpicid (word "btn_ this.size "_mask)
	if this.size = "small [this.width.val 50 this.height.val 30]
	if this.size = "normal [this.width.val 94 this.height.val 39]
	if this.size = "big [this.width.val 100 this.height.val 60]]
.listen "style [if not this.keepback = 0 [cancel] this.pic.val hair.resource.getpicid (word "btn_ this.size "_ this.style "_wait) this.mask.val hair.resource.getpicid (word "btn_ this.size "_mask)]
.listen "hotkey [if not this.hotkey = this.hotkey.h [this.key this.hotkey [run this.click]]]
.listen "mousestatus [if this.mousestatus = this.mousestatus.h [cancel] this.pic.val hair.resource.getpicid (word "btn_ this.size "_ this.style "_ this.mousestatus) this.mask.val hair.resource.getpicid (word "btn_ this.size "_mask) if this.mousestatus = "click [this.text.val this.text run hair.object.replace this.objname this.click 1]
	if this.mousestatus = "press [this.text.val this.text run hair.object.replace this.objname this.press 1] if this.mousestatus = "hover [this.text.val this.text run hair.object.replace this.objname this.hover 1] if this.mousestatus = "wait [this.text.val this.text run hair.object.replace this.objname this.wait 1]]
.listen "text [( this._render se this.xpos this.ypos se this.width this.height )]
;采用noflicker防止闪烁，不建议在场景刷新后操作按钮，即改变大小，改变位置，改变样式，改变文字。
.listen "xpos []
.listen "ypos []
.listen "draw []
.listen "pic []

;创建标签类继承画布类
new "Tag "Class
.inherit "Canvas
.before [this.width.val this.length * first labelsize first this.text this.height.val (last labelsize first this.text ) * (1+int (count this.text ) / this.length )]
.attr [text 这是一个tag color black length 20 draw [pu setxy xcor+1 ycor-1 pd setpencolor this.color make "_tagtext this.text repeat int (count this.text ) / this.length [hair.old.tt hair.base.getitem this.length :_tagtext make "_tagtext hair.base.delitem this.length :_tagtext pu bk (last labelsize first this.text ) pd] hair.old.tt :_tagtext setpencolor "black]]
.listen "text [this.width.val this.length * first labelsize first this.text this.height.val (last labelsize first this.text ) * (1+int (count this.text ) / this.length ) ( this._render se this.xpos this.ypos se this.width this.height )]
.listen "length [this.width.val this.length * first labelsize first this.text this.height.val (last labelsize first this.text ) * (1+int (count this.text ) / this.length ) ( this._render se this.xpos this.ypos se this.width this.height )]
.listen "color [this.width.val this.length * first labelsize first this.text this.height.val (last labelsize first this.text ) * (1+int (count this.text ) / this.length ) ( this._render se this.xpos this.ypos se this.width this.height )]
.listen "mousestatus []
.listen "draw []
end

bury "hair.gui.reg
