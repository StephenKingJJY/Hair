;输出数组的大小
;标准同$array的参数
;命令版本号v1.4
;已知问题包括查看大小之后会改变数组（danger）

to hair.base.arraysize :a
hair.detect
if not array? :a [hair.debug.error _e "参数不是数组 stop]
;首先确定有多少个维度，在这里算法是渐进的取每个维度的第一项，直到出错
local "nothing
localmake "a_s 0
localmake "a2 :a
localmake "wakaka 0
while [:wakaka=0] [hair.base.makep "a_s catch "error [hair.old.aset :a2 hair.base.arraysize.repeat :a_s [] make "wakaka 1] ifelse :wakaka = 0 [make "wakaka 1] [make "wakaka 0]]
hair.base.makem "a_s
;得到维度的个数，递归确认每个维度的大小
local "i
localmake "a_s2 hair.base.arraysize.repeat :a_s
for [i 1 :a_s][
  catch "error [forever [make "nothing hair.old.aget :a :a_s2 make "a_s2 (se hair.base.getitem :i-1 :a_s2 (item :i :a_s2)+1 hair.base.delitem :i :a_s2)]]
  make "a_s2 (se hair.base.getitem :i-1 :a_s2 (item :i :a_s2)-1 hair.base.delitem :i :a_s2)
]
op map [? + 1] :a_s2
end
to hair.base.arraysize.repeat :x
;生成指定个数的[0 0 0 0]表
localmake "list0 []
repeat :x [queue "list0 0]
op :list0
end
bury [hair.base.arraysize hair.base.arraysize】
