;新建对象
;读取类中的数据创建对象
;默认创建objname,class属性，提供对this的解释，挂载list，创建对象过程
;对象的复制copy(下版本？)
;命令版本号v1.3

to hair.object.new :name :class
hair.detect
;当新建的是一个类的时候直接调用class命令处理
if :class = "Class [hair.object.class :name stop]
;对象名合法性判断
if or member? :name :hair_object_list PROCEDURE? :name [hair.debug.error "对象名被占用 stop]
if member? :name :hair_keepword [hair.debug.error "对象名非法 stop]
if not proplist? word "hair_object_class_ :class [hair.debug.error "此类不存在 stop]

;定义xx.过程显示所有可用操作提示
make (word "hair_object_ :name "_tip) []
define word :name ". hair.object.replace :name [[][hair.object.refresh __name op thing (word "hair_object_ __name "_tip)]] 3

;首先定义内置的对象属性
queue (word "hair_object_ :name "_tip) ".objname
queue (word "hair_object_ :name "_tip) ".class
define word :name ".objname hair.object.replace :name [[][hair.object.refresh __name op __name]] 3
define word :name ".class hair.object.replace :name [[][hair.object.refresh __name op __x]] se 3 :class
if not member? "objname :hair_object_havedefine [define ".objname [[][]] queue "hair_object_havedefine "objname]
if not member? "class :hair_object_havedefine [define ".class [[][]] queue "hair_object_havedefine "class]

;创建一个对象过程，显示不能直接使用对象
define :name [[][hair.debug.error "您不能直接使用对象]]

;开始解析所有的继承关系
make "attr_temp []
make "method_temp []
make "listen_temp []
make "beaf_temp []
findinherit :class

;解释this
make "beaf_temp hair.object.replace :name :beaf_temp 1
make "method_temp hair.object.replace :name :method_temp 1
make "listen_temp hair.object.replace :name :listen_temp 1

;创建相关属性
repeat (count :attr_temp)/2 [hair.object.regdot :name item repcount*2-1 :attr_temp item repcount*2 :attr_temp 1]
;for [i 1 (count :attr_temp)/2] [hair.object.regdot :name item :i*2-1 :attr_temp item :i*2 :attr_temp 1]

;处理before问题
localmake "_cancel 0
catch "cancel [run first :beaf_temp make "_cancel 1]
if :_cancel = 0 [
  ;因为cancel抛出而删除之前创建的属性
  ;1.删除tip变量和xx.过程
  ;bury se word ("hair_object_ :name "_tip) word :name ".
  ;2.删除objname和class属性以及其他属性
  ;3.移除对象过程和取消挂载
  hair.object.destroy :name stop
]

;挂载对象到对象列表
queue "hair_object_list :name

;创建方法、保存after内容
repeat (count :method_temp)/2 [hair.object.regdot :name item repcount*2-1 :method_temp item repcount*2 :method_temp 2]
;for [i 1 (count :method_temp)/2] [hair.object.regdot :name item :i*2-1 :method_temp item :i*2 :method_temp 2]
make (word "hair_object_ :name "_after) last :beaf_temp

;在属性变动时实施listen中的内容，即调用创建属性时保留的钩子函数入口，注意对cancel的解析应该为恢复原值并且终止listen过程
repeat (count :listen_temp)/2 [hair.hook.bind (word :name ". item repcount*2-1 :listen_temp "_onchange) se [catch "cancel] (list se [run] (list item repcount*2
  hair.object.replace :name :listen_temp se 2 (word :name ". item repcount*2-1 :listen_temp ".cancel)))]

;执行new也需要刷新简化，但是因为调用了相关内容，所以应该放在最后，即被cancel了就无法简化
hair.object.refresh :name

end

;查询所有的继承类，并汇总
to findinherit :curclass
;首先是不断递归找到最底层的继承类
if member? "inherit replaceattr2 plist word "hair_object_class_ :curclass [findinherit gprop word "hair_object_class_ :curclass "inherit]

;汇总所有的属性定义，遇到相同的属性以最后定义的为准
localmake "attr_cur gprop word "hair_object_class_ :curclass "attr
replaceattr :attr_cur replaceattr2 :attr_temp

;相同的方法被最后一次定义覆盖
localmake "method_cur gprop word "hair_object_class_ :curclass "method
replacemethod :method_cur replaceattr2 :method_temp :curclass

;相同的监听被最后一次定义覆盖
localmake "listen_cur gprop word "hair_object_class_ :curclass "listen
replacelisten :listen_cur replaceattr2 :listen_temp :curclass

;before和after支持叠加，存在取到错误默认值的情况，但这是代码问题，框架这里不做判断
if empty? :beaf_temp [make "beaf_temp [[][]]]
make "beaf_temp list (se gprop word "hair_object_class_ :curclass "before first :beaf_temp) (se gprop word "hair_object_class_ :curclass "after last :beaf_temp)

;已知的问题是存在重复继承，暂不处理
end

to replacemethod :cur :temp :class
if empty? :cur [stop]
ifelse not member? first :cur :temp [make "temp se :temp first :cur make "method_temp (se :method_temp first :cur (list gprop word "hair_object_class_ :class first :cur))] [
  localmake "index_temp hair.base.index first :cur :temp
  make "method_temp (se hair.base.getitem :index_temp*2-1 :method_temp (list gprop word "hair_object_class_ :class first :cur) hair.base.delitem :index_temp*2 :method_temp)]
replacemethod bf :cur :temp :class
end

to replacelisten :cur :temp :class
if empty? :cur [stop]
ifelse not member? first :cur :temp [make "temp se :temp first :cur make "listen_temp (se :listen_temp first :cur (list gprop word "hair_object_class_ :class first :cur))] [
  localmake "index_temp hair.base.index first :cur :temp
  make "listen_temp (se hair.base.getitem :index_temp*2-1 :listen_temp (list gprop word "hair_object_class_ :class first :cur) hair.base.delitem :index_temp*2 :listen_temp)]
replacelisten bf :cur :temp :class
end


to replaceattr :cur :temp
if empty? :cur [stop]
ifelse not member? first :cur :temp [make "temp se :temp first :cur make "attr_temp se :attr_temp hair.base.getitem 2 :cur] [
  localmake "index_temp hair.base.index first :cur :temp
  make "attr_temp (se hair.base.getitem :index_temp*2-1 :attr_temp (list first bf :cur) hair.base.delitem :index_temp*2 :attr_temp)]
replaceattr bf bf :cur :temp
END

;删除temp中所有的偶数项，即属性表中所有的属性内容，保留属性的名称
to replaceattr2 :temp
if (count :temp)<2 [op :temp]
localmake "counttemp (count :temp)/2
for [i 1 :counttemp][make "temp hair.base.bmitem :i*2-:i+1 :temp]
op :temp
END

to cancel
throw "cancel
end

bury [hair.object.new findinherit replaceattr replaceattr2 replacemethod replacelisten cancel]
buryname [attr_temp method_temp listen_temp beaf_temp]
